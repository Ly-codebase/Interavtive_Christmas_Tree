<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ„ Merry Christmas</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            color: #E6E6E6;
            font-family: sans-serif;
            position: relative;
        }
        canvas {
            display: block;
        }
        
        /* 5. èƒŒæ™¯è‰ºæœ¯å­—ï¼šMerry Christmas */
        body::before {
            content: "Merry Christmas";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8vw;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.05);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.1), 0 0 20px rgba(255, 255, 255, 0.05);
            z-index: 1;
            pointer-events: none;
            text-align: center;
            letter-spacing: 0.1em;
            line-height: 1.2;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            z-index: 10;
            color: #ffffff;
        }
        #mediaPipeContainer {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 200px;
            height: 150px;
            border: 2px solid #D4AF37;
            border-radius: 8px;
            overflow: hidden;
            z-index: 10;
        }
        #mediaPipeVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            display: none;
        }
        #mediaPipeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.umd.js"></script>

    <script type="importmap">{
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.module.js",
            "three/examples/jsm/postprocessing/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/",
            "three/examples/jsm/shaders/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/shaders/"
        }
    }</script>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1633552471/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.4.1633552471/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.4.1633552471/camera_utils.js"></script>
</head>
<body>
    <div id="mediaPipeContainer">
        <video id="mediaPipeVideo" autoplay playsinline></video>
        <canvas id="mediaPipeCanvas"></canvas>
    </div>

    <div id="info">
        çŠ¶æ€: **åˆå§‹åŒ–ä¸­** ...
    </div>

<script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

        // --- æ ¸å¿ƒå˜é‡ ---
        let scene, camera, renderer, clock;
        let composer;
        let particles;      
        let ribbonParticles;    
        let starOrnament;       
        let hands;          
        
        let isScattered = false;    
        const ELEMENTS_COUNT = 25000;    
        const RIBBON_COUNT = 500;
        const treeHeight = 12;
        const maxRadius = 5;
        
        const currentPositions = [];    
        const targetPositions = [];    
        const initialPositions = [];    

        const COLORS = {
            // é‡æ–°ä½¿ç”¨æ·±ç»¿ï¼Œä½†æˆ‘ä»¬ç”¨ Bloom é˜ˆå€¼æ¥ç¡®ä¿å…¶å¯è§æ€§
            darkGreen: new THREE.Color(0x004d40),
            gold: new THREE.Color(0xFFD700),
            red: new THREE.Color(0xCC0000),
            white: new THREE.Color(0xFFFFFF)
        };
        const EMISSIVE_COLORS = [];    

        // ç§»é™¤æ‰€æœ‰çº¹ç†åŠ è½½ä»£ç ï¼Œä»¥ä¿è¯å…¼å®¹æ€§ã€‚

        const videoElement = document.getElementById('mediaPipeVideo');
        const canvasElement = document.getElementById('mediaPipeCanvas');
        const canvasCtx = canvasElement.getContext('2d');
        const TWEEN = window.TWEEN;

        // --- MediaPipe å’Œ Tween é€»è¾‘ï¼ˆä¿æŒä¸å˜ï¼‰ ---
        window.onResults = function(results) { 
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const handLandmarks = results.multiHandLandmarks[0];
                
                if (window.drawConnectors && window.drawLandmarks) {
                    window.drawConnectors(canvasCtx, handLandmarks, window.HAND_CONNECTIONS, {color: '#F0E68C', lineWidth: 3});
                    window.drawLandmarks(canvasCtx, handLandmarks, {color: '#cc0000', lineWidth: 1, radius: 5});
                }

                const tip_index = handLandmarks[8];
                const palm = handLandmarks[0];
                const dist_index = Math.abs(tip_index.y - palm.y);
                const threshold = 0.2;
                let isFist = dist_index < threshold;
                
                if (window.particles) {
                    if (isFist && window.isScattered) { window.setChristmasTreeState(false); }
                    else if (!isFist && !window.isScattered) { window.setChristmasTreeState(true); }
                }
            }
            canvasCtx.restore();
        };

        window.setChristmasTreeState = function(scatter) { 
            if (window.isScattered === scatter) return;
            window.isScattered = scatter;    

            document.getElementById('info').innerHTML =    
                `çŠ¶æ€: **${scatter ? 'æ•£å¼€æ€' : 'åˆæ‹¢æ€'}** <br> æ‰‹åŠ¿: **æ¡æ‹³** (åˆæ‹¢) / **å¼ å¼€** (æ•£å¼€)`;
            
            const target = scatter ? targetPositions : initialPositions;
            const positionsAttribute = particles.geometry.attributes.position;
            const positionsArray = positionsAttribute.array;

            for (let i = 0; i < ELEMENTS_COUNT; i++) {
                const startIndex = i * 3;
                const startPos = { x: currentPositions[startIndex], y: currentPositions[startIndex + 1], z: currentPositions[startIndex + 2] };
                const endPos = { x: target[startIndex], y: target[startIndex + 1], z: target[startIndex + 2] };

                new TWEEN.Tween(startPos)
                    .to(endPos, 2500)
                    .easing(TWEEN.Easing.Quadratic.InOut)
                    .onUpdate(() => {
                        currentPositions[startIndex]     = startPos.x;
                        currentPositions[startIndex + 1] = startPos.y;
                        currentPositions[startIndex + 2] = startPos.z;
                        
                        positionsArray[startIndex] = startPos.x;
                        positionsArray[startIndex + 1] = startPos.y;
                        positionsArray[startIndex + 2] = startPos.z;
                        positionsAttribute.needsUpdate = true;
                    })
                    .start();
            }
        }


        // --- åˆå§‹åŒ–å’Œæ¸²æŸ“å¾ªç¯ ---

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 18;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);
            
            clock = new THREE.Clock();
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.05));

            initMediaPipe();

            createParticleSystem();
            createRibbonParticles();
            createStarOrnament();

            setupPostProcessing();

            setupCamera();
            window.addEventListener('resize', onWindowResize, false);
            
            animate();
            
            document.getElementById('info').innerHTML =    
                `çŠ¶æ€: åˆæ‹¢æ€ (åˆå§‹) <br> æ‰‹åŠ¿: æ¡æ‹³ (åˆæ‹¢) / å¼ å¼€ (æ•£å¼€)`;
        }
        
        function createStarOrnament() {
            const geometry = new THREE.SphereGeometry(0.5, 32, 32); 
            const material = new THREE.MeshPhongMaterial({
                color: COLORS.gold,
                emissive: COLORS.gold,
                emissiveIntensity: 3, 
                flatShading: false
            });
            starOrnament = new THREE.Mesh(geometry, material);
            starOrnament.position.set(0, treeHeight / 2 + 0.8, 0); 
            scene.add(starOrnament);
        }

        /**
         * ä¿®å¤ 2: ä½¿ç”¨é«˜å…¼å®¹æ€§ PointsMaterial
         */
        function createRibbonParticles() {
            const positions = [];
            const colors = [];
            const goldColor = COLORS.gold;

            for (let i = 0; i < RIBBON_COUNT; i++) {
                const fraction = i / RIBBON_COUNT;
                const y = fraction * treeHeight - (treeHeight / 2);
                
                const radius = (maxRadius * (1 - fraction * 0.7)) * 0.7; 
                const angle = fraction * Math.PI * 15 + Math.random() * 0.5;
                
                const x = Math.cos(angle) * radius + (Math.random() - 0.5) * 0.2;
                const z = Math.sin(angle) * radius + (Math.random() - 0.5) * 0.2;
                
                positions.push(x, y, z);
                colors.push(goldColor.r, goldColor.g, goldColor.b);
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 2.0, // **æµ‹è¯•ï¼šè®¾ç½®è¶…å¤§å°ºå¯¸**
                // ç§»é™¤ map å±æ€§
                vertexColors: true,
                blending: THREE.NormalBlending, // ä½¿ç”¨æœ€ç®€å•æ··åˆæ¨¡å¼
                transparent: true,
                sizeAttenuation: false, // å¼ºåˆ¶æ’å®šå°ºå¯¸
                depthTest: false, 
                depthWrite: false
            });

            ribbonParticles = new THREE.Points(geometry, material);
            scene.add(ribbonParticles);
        }

        /**
         * 3. ä¿®å¤ 2: ä½¿ç”¨é«˜å…¼å®¹æ€§ PointsMaterial
         */
        function createParticleSystem() {
            const positions = [];
            
            for (let i = 0; i < ELEMENTS_COUNT; i++) {
                const y = (Math.random() * treeHeight) - (treeHeight / 2);    
                const radius = maxRadius * (1 - (y + (treeHeight / 2)) / treeHeight);
                
                const currentRadius = radius * Math.random() * (0.5 + 0.5 * Math.random());
                const angle = Math.random() * Math.PI * 2;
                const x = Math.cos(angle) * currentRadius;
                const z = Math.sin(angle) * currentRadius;

                positions.push(x, y, z);
                initialPositions.push(x, y, z);
                currentPositions.push(x, y, z);    

                const targetX = (Math.random() - 0.5) * 60;
                const targetY = (Math.random() - 0.5) * 60;
                const targetZ = (Math.random() - 0.5) * 60;
                targetPositions.push(targetX, targetY, targetZ,);    
                
                const normalizedY = (y + treeHeight / 2) / treeHeight;
                let color;
                if (normalizedY < 0.1 || normalizedY > 0.9) {
                    color = Math.random() < 0.5 ? COLORS.white : COLORS.gold;
                } else if (Math.random() < 0.8) {
                    color = COLORS.darkGreen; 
                } else {
                    const r = Math.random();
                    if (r < 0.3) color = COLORS.gold;
                    else if (r < 0.6) color = COLORS.red;
                    else color = COLORS.white;
                }
                EMISSIVE_COLORS.push(color.r, color.g, color.b);
            }

            const particleGeometry = new THREE.BufferGeometry();
            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.Float32BufferAttribute(EMISSIVE_COLORS, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 1.5, // **æµ‹è¯•ï¼šè®¾ç½®è¶…å¤§å°ºå¯¸**
                // ç§»é™¤ map å±æ€§
                vertexColors: true,
                blending: THREE.NormalBlending, // ä½¿ç”¨æœ€ç®€å•æ··åˆæ¨¡å¼
                transparent: true,
                sizeAttenuation: false, // å¼ºåˆ¶æ’å®šå°ºå¯¸
                depthTest: false, 
                depthWrite: false
            });

            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            window.particles = particles;
        }

        function initMediaPipe() {
            hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1633552471/${file}`;
            }});
            
            hands.setOptions({    
                maxNumHands: 1,    
                modelComplexity: 1,    
                minDetectionConfidence: 0.7,    
                minTrackingConfidence: 0.5    
            });
            
            window.hands = hands;    
            hands.onResults(window.onResults);    
        }

        /**
         * ä¿®å¤ 3: å¼ºåˆ¶æœ€ä½é˜ˆå€¼
         */
        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));

            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                2.0, // å¼ºåº¦ï¼šé«˜
                0.4, // åŠå¾„
                0.0  // **æµ‹è¯•ï¼šé˜ˆå€¼è®¾ä¸º 0.0ï¼Œç¡®ä¿æ‰€æœ‰ä¸œè¥¿éƒ½è¾‰å…‰**
            );
            
            composer.addPass(bloomPass);
        }
        
        function setupCamera() {
            if (!navigator.mediaDevices?.getUserMedia) {
                console.error('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®ã€‚');
                return;
            }
        
            navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } })
                .then(stream => {
                    // å…³é”®1ï¼šåªè®¾ç½®ä¸€æ¬¡ srcObject
                    if (videoElement.srcObject !== stream) {
                        videoElement.srcObject = stream;
                    }
        
                    // å…³é”®2ï¼šè®© CameraHelper å…¨æƒç®¡ç† play()ï¼Œæˆ‘ä»¬ä¸å†æ‰‹åŠ¨ play()
                    // åˆ é™¤è¿™è¡Œï¼švideoElement.play();
        
                    const videoWidth = videoElement.videoWidth || 640;
                    const videoHeight = videoElement.videoHeight || 480;
                    canvasElement.width = videoWidth;
                    canvasElement.height = videoHeight;
        
                    if (window.Camera && hands) {
                        const cameraHelper = new window.Camera(videoElement, {
                            onFrame: async () => { await hands.send({ image: videoElement }); },
                            width: videoWidth,
                            height: videoHeight
                        });
                        // Camera.start() ä¼šå®‰å…¨åœ°è°ƒç”¨ play()ï¼ˆå¸¦é˜²é‡é€»è¾‘ï¼‰
                        cameraHelper.start();
                    }
                })
                .catch(err => {
                    console.error('æ— æ³•è·å–æ‘„åƒå¤´æƒé™:', err);
                });
        }

        function animate() {
            requestAnimationFrame(animate);

            TWEEN.update();
            const elapsedTime = clock.getElapsedTime();

            if (particles) {
                particles.rotation.y += 0.001;
            }
            
            if (ribbonParticles) {
                ribbonParticles.rotation.y = elapsedTime * 0.2;
            }

            if (starOrnament) {
                if (window.isScattered) {
                    starOrnament.rotation.y += 0.01;
                    starOrnament.position.y = (treeHeight / 2 + 0.8) + Math.sin(elapsedTime * 2) * 0.5;
                } else {
                    starOrnament.rotation.y += 0.005;
                    starOrnament.position.y = treeHeight / 2 + 0.8;
                }
            }
            
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        init();
    </script>
</body>
</html>





